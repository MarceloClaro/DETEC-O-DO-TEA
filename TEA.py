# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aDop73YQxlbj1oCJpTc4yX9ap1N-tw_9
"""



import streamlit as st
import numpy as np
import pandas as pd
import os
import zipfile
from PIL import Image
import tensorflow as tf
import time 
import matplotlib
matplotlib.use('agg')  
import matplotlib.pyplot as plt


# Create a function to generate the autoencoder
def createAutoencoder():
    # Get the dataset
    from tensorflow.keras.datasets import mnist
    (x_train, y_train), (x_test, y_test) = mnist.load_data()
    
    # Normalize the data
    x_train = x_train.astype('float32')/255.
    x_test = x_test.astype('float32')/255.
    
    # Reshape images from 28x28 to 32x32
    x_train = np.pad(x_train,((0,0),(2,2),(2,2)),'constant', constant_values=0)
    x_test = np.pad(x_test,((0,0),(2,2),(2,2)), 'constant', constant_values=0)
    
    # Create the model
    autoencoder = tf.keras.models.Sequential([tf.keras.layers.InputLayer(input_shape=(32, 32, 1)),
                                              tf.keras.layers.Conv2D(16,(3,3), activation='relu', padding='same'), 
                                              tf.keras.layers.MaxPooling2D(pool_size=(2,2)), 
                                              tf.keras.layers.Conv2D(8,(3,3), activation='relu', padding='same'), 
                                              tf.keras.layers.MaxPooling2D(pool_size=(2,2)),
                                              tf.keras.layers.Conv2D(8,(3,3), activation='relu', padding='same'),                                            
                                              tf.keras.layers.UpSampling2D(),
                                              tf.keras.layers.Conv2D(16,(3,3), activation='relu', padding='same'),
                                              tf.keras.layers.UpSampling2D(),
                                              tf.keras.layers.Conv2D(1,(3,3), activation='sigmoid', padding='same')]) 
    
    autoencoder.compile(optimizer='adam', loss='binary_crossentropy')
    autoencoder.summary()
    
    # Reshape data to fit the model
    x_train = x_train.reshape(-1, 28, 28, 1)
    x_test = x_test.reshape(-1, 28, 28, 1)
    
    # Train the model and save it
    autoencoder.fit(x_train, x_train, epochs=10, batch_size=128,
                    shuffle=True, validation_data=(x_test, x_test))
    autoencoder.save_weights('./autoencoder_mnist.h5')
    
# Create a function to load the dataset
def downloadAndUnzip():
    filename = 'AutData.zip'

    if not os.path.exists(filename):
        !wget -q\"https://drive.google.com/file/d/14zeNkO1cHKnCEa-pFwnZVB4yk3MKu8XJ/view?usp=share_link"\ -O AutData.zip
        zipped_data = zipfile.ZipFile(filename, 'r')
        zipped_data.extractall()

# Create a function to load the images
def loadImages():
    img_data =[]
    labels =[]

    #Load Autistic Images
    autistic_images_list = os.listdir('./AutData/NonAutData/')
    autistic_path = './AutData/AutData/'
    for autistic_img in autistic_images_list:
        labels.append(1)
        img = Image.open(autistic_path+autistic_img).convert('L')
        img_data.append(np.array(img))
    
    #Load Non-Autistic Images
    non_autistic_images_list = os.listdir('./AutData/NonAutData/')
    non_autistic_path = './AutData/NonAutData/'
    for non_autistic_img in non_autistic_images_list:
        labels.append(2)
        img = Image.open(non_autistic_path+non_autistic_img).convert('L')
        img_data.append(np.array(img))
    
    # Reshape images
    img_data = np.array(img_data).reshape(-1, 28, 28, 1).astype('float16')

    # Normalize the data
    img_data /= 255.
    return img_data, labels

# Create a function to build the model
def buildModel():
    model = tf.keras.Sequential([
        tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(28, 28, 1)),
        tf.keras.layers.MaxPooling2D((2, 2)),
        tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
        tf.keras.layers.MaxPooling2D((2, 2)),
        tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(64, activation='relu'),
        tf.keras.layers.Dense(2, activation='softmax')
    ])
    model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
    return model

#
def plotGraph(history):
# Plot of accuracy vs. epochs
    acc = history.history['accuracy']
    epochs = range(len(acc))
    fig = plt.figure(figsize=(7,4))
    plt.plot(epochs, acc)
    plt.title('Model accuracy')
    plt.ylabel('Accuracy')
    plt.xlabel('Epoch')
    plt.legend(['Train', 'Test'], loc='upper left')
    return st.pyplot(fig)

#
def plotResults():
    # Plot results of accuracy
    plt.figure(figsize=(16, 6))
    plt.subplot(1, 2, 1)
    sns.heatmap(cm_test, annot=True, cmap="Blues", fmt="d", 
                xticklabels=class_names, 
                yticklabels=class_names)
    plt.title("Confusion Matrix - Test Set")
    plt.xlabel("Predicted label")
    plt.ylabel("True label")

    # Plot results of accuracy
    plt.subplot(1, 2, 2)
    sns.heatmap(cm_train, annot=True, cmap="Blues", fmt="d", 
                xticklabels=class_names, 
                yticklabels=class_names)
    plt.title("Confusion Matrix - Train Set")
    plt.xlabel("Predicted label")
    plt.ylabel("True label")

# Create a main function
def main():
    st.title('Image Classification using Neural Networks')

    # Create a sidebar menu
    st.sidebar.header('Autism Image Classification')
    menu = ["Download & Unzip", "Create Autoencoder","Train Model and Classify Images","Results & Conclusions"]
    choice = st.sidebar.selectbox("Menu", menu)

    # Download and unzip the dataset
    if choice == "Download & Unzip":
        with st.spinner('Downloading and unzipping dataset...'):
            time.sleep(3)
            st.success('Download and unzip successful!')
            downloadAndUnzip()


    # Create a CNN autoencoder
    if choice == "Create Autoencoder":
        st.subheader('Create Autoencoder using Convolutional Neural Networks')
        st.write('An autoencoder is an unsupervised machine learning algorithm that takes an input image and encodes it into a set of features, which can be used to reconstruct the original input.')
        option = st.selectbox("Options",["Create Autoencoder","View Summary of Autoencoder Model"])

        # Create an autoencoder
        if option == "Create Autoencoder":
            with st.spinner('Creating autoencoder...'):
                time.sleep(3)
                st.success('Autoencoder created successfully!')
                createAutoencoder()

        
        # View the autoencoder summary
        if option == "View Summary of Autoencoder Model":
            st.write(tf.keras.models.load_model('autoencoder_mnist.h5').summary())


    # Train the model and classify images
    if choice == "Train Model and Classify Images":
        st.subheader('Train Model and Classify Images')
        option = st.radio("Options",("Train Model","Classify Images"))

        # Train the model
        if option == "Train Model":
            # Load the data
            img_data, labels = loadImages()

            # Split the data
            from sklearn.model_selection import train_test_split
            X_train, X_test, y_train, y_test = train_test_split(img_data, labels,
                                                            random_state=1,
                                                            test_size = 0.2)

            # Create the model
            model = buildModel()

            # Train the model
            with st.spinner('Training model...'):
                time.sleep(3)
            history = model.fit(X_train, y_train,
                        epochs=10,
                        validation_data=(X_test, y_test))

            plotGraph(history)
            st.success("Model trained successfully!")


        # Classify images
        if option == "Classify Images":
            # Load a new image
            newImage = st.file_uploader("Upload an Image", type="jpg")

            # Predict the class
            if newImage is not None:
                with st.spinner('Classifying image...'):
                    time.sleep(3)
                newImage = Image.open(newImage).convert('L')
                
                # Reshape the image
                img = np.array(newImage).reshape(-1, 28, 28, 1).astype('float16')

                 # Normalize the data
                img /= 255.
                
                # Load the model
                model = buildModel()
                model.load_weights('autoencoder_mnist.h5')
                probabilities = model.predict(img)
                
                # Get the class
                if np.argmax(probabilities) == 0:
                    class_name = 'Autistic'
                else:
                    class_name = 'Non-autistic'
                st.write('The image is classified as: ', class_name)
                st.success('Classification successful!')


    # Show results and conclusions
    if choice == "Results & Conclusions":
        st.subheader('Classification Results & Conclusions')

        # Confusion matrix
        from sklearn.metrics import confusion_matrix
        cm_test = confusion_matrix(y_test, y_pred_test)
        cm_train = confusion_matrix(y_train, y_pred_train)

        # Get the class names
        class_names = ['Autistic','Non-autistic']

        # Confusion matrix
        plotResults()

        # Accuracies
        st.write('The testing accuracy is: %.2f' % accuracy_test)
        st.write('The training accuracy is: %.2f' % accuracy_train)

        # Conclusions
        st.write('The results obtained show that the autoencoder was able to classify images with an accuracy of %.2f on the test set and %.2f on the train set.' % (accuracy_test, accuracy_train))

if __name__ == '__main__':
    main()
